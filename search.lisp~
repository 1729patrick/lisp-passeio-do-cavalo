; dfs2.lisp
;; by Kerstin Voigt, after Paul Graham, pp. 52, 
;; collects paths, returns shortest solution path;

;; assume the following:
;; (1) graph is a list of sublists (n1 n2 n3 ... nk) where
;; n2 ... nk are neighbours of n1; graph is DIRECTED
;; and ACYCLIC (for now);
;; (2) start is the start node of search
;; (3) goal is the goal node to be reached;
;; (4) open is a list of nodes whose successors have
;;     not yet been "tried" yet;

;; search tries to move from start to goal
;; with plain depth-first search;

(defun dfsearch (start goal graph)
  (path-dfs goal (list (list start)) graph)
  )

;; plain dfs;
(defun path-dfs (goal open graph)
  (if (null open)
      nil
    (let* ((path (car open))
	   (node (car path))
	   )
      
      (terpri)
      (format t "OPEN: ~A PATH: ~A  NODE: ~A" open path node)
      (terpri)
      
      (if (eql node goal)
	  (reverse path)
	(path-dfs goal 
		   (append 
		    (successor-path node graph)
		    (cdr open))
		   graph)
	))
    ))

(defun successor-path (node graph)
  (let* (
         (line (successor-line node graph))
         (line-index (position line graph))
         (column-index (position node line))
         )

    (list line-index column-index) 
    )
  )


(defun successor-line (node graph)
  (let (
        (line (apply #'append
                     (mapcar
                      (lambda (lin) 
                        (cond
                         ((position node lin) lin)
                         (T nil)
                         )
                        )
                      graph
                      ))
              ))
  
    line
    )
  )

(defun successor-avaliable (line-index column-index graph)
  (cond
   ass1wsaasssaasasdsadsadsasdsadsadsss
   ( )
)
)

(defun successor-value (line-index column-index graph)
  (let* (
         (line (nth line-index graph))
         (value (nth column-index line))
         )
    value
    )
  )
 



;; a graph for testing: a to b and c, b to c, c to d;
;;(setq graph '((a b c) (b c) (c d)))

(setq graph '((a b c) (b c e) (c d) (d e f) (e f) (f g h) (h g))) 